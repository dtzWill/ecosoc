# Example's Gallery #

In this page we show some examples of programs, and the results that
out flow tracker analysis produces for them. For all examples, our secret is the variable pw. We use the following keys in the
table:

  * **C-Src**: the C program that we have analyzed. This is an actual program, i.e., the very input to our analyzer.
  * **Full Dep Graph**: the complete Dependence Graph with control edges and data edges. Each vertex is labeled with one operand or operator.
  * **Tainted Sub Graph**:the Dependence Graph which IS produced by our tool. This DFG has the respective line numbers from source file and is useful for developer to identify the vulnerability in the code. Note that the SUB-DFG is one example, however the tool can to produce more than one SUB-DFG if there exists several vulnerable paths. In red color is the shortest path which connects the secret to a branch instruction.
  * **TXT-Lines**: ASCII format of the path in red color presented at "Taited Sub Graph".

| **C-Src** | **Full Dep Graph** | **Tainted Sub Graph**| **TXT-Lines** | **Comments** |
|:----------|:-------------------|:---------------------|:--------------|:-------------|
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex1/ex1.c) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex1/fullGraph.png) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex1/subgraphLines0.png) | [![](http://cuda.dcc.ufmg.br/flowtracker/examples/images.png)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex1/subgraphASCIILines0.txt)|**ex1.c**: This is an example of naive string matching algorithm. The function compVar does not execute at constant time because the return instruction inside the loop could ends the function before the last iteration for some inputs.  |
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex2/ex2.c) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex2/fullGraph.png) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex2/subgraphLines0.png) | [![](http://cuda.dcc.ufmg.br/flowtracker/examples/images.png)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex2/subgraphASCIILines0.txt)|**ex2.c**: Again, an example of naive string matching algorithm. The function compVar does not execute at constant time because the attribution of variable isEqual could not be done for some input. |
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex3/ex3.c) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex3/fullGraph.png) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/safe.jpg) | ![![](http://cuda.dcc.ufmg.br/flowtracker/examples/images.png)](http://cuda.dcc.ufmg.br/flowtracker/safe.jpg)|**ex3.c**: This is a good example of a function for string comparisson which runs in constant time and can be used in cryptosystem's implementation. Of course, our tool did not found any vulnerable tainted subgraph in this example.   |
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex4/ex4.c) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex4/fullGraph.png) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/safe.jpg) | ![![](http://cuda.dcc.ufmg.br/flowtracker/examples/images.png)](http://cuda.dcc.ufmg.br/flowtracker/safe.jpg)|**ex4.c**: Again, this example runs in constant time. Of course we have a branch instruction, but it is not problematic because the loop runs for constant iterations and the cost of each iteration is the same. Therefore our tool did not found any tainted subgraph in this example.  |
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex5/ex5.c) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex5/fullGraph.png) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/safe.jpg) | ![![](http://cuda.dcc.ufmg.br/flowtracker/examples/images.png)](http://cuda.dcc.ufmg.br/flowtracker/safe.jpg)|**ex5.c**: Another example which the code runs in constant time. In this case the branch instruction for the while loop is influenced by information stored in the secret variable. However, again this loop runs all iteration and therefore the code is not dangerous. Of course, our too did not found any problem with this code.   |
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex6/ex6.c) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex6/fullGraph.png) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex6/subgraphLines0.png) | [![](http://cuda.dcc.ufmg.br/flowtracker/examples/images.png)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex6/subgraphASCIILines0.txt)|**ex6.c**: At this example, the number of instructions in both side of branch instruction (true and false) is the same. However the execution time could be non constant because architectural aspects like cache miss, speculative execution and the respective pipeline flush for instance. So, Flow Tracker informs a vulnerability at this code.    |
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex7/ex7.c) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex7/fullGraph.png) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/safe.jpg) | ![![](http://cuda.dcc.ufmg.br/flowtracker/examples/images.png)](http://cuda.dcc.ufmg.br/flowtracker/safe.jpg)|**ex7.c**: This example uses a ternary operator in order to make a test. LLVM compiler translate this C code in such way that no branch instruction is generated. So, this example is safe because the translation is good.     |
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex8/ex8.c) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex8/fullGraph.png) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex8/subgraphLines0.png) | [![](http://cuda.dcc.ufmg.br/flowtracker/examples/images.png)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex8/subgraphASCIILines0.txt)|**ex8.c**: Here we have an example where a secret information is used to memory indexing. So, this code is vulnerable to a attack named cache-timing attack. The rule for avoiding cache-timing attacks is "Avoid table look-ups indexed by secret data". That's the rule stated in http://cryptocoding.net. Flow Tracker can find this kind of vulnerability.     |
| [![](http://homepages.dcc.ufmg.br/~fernando/images/c.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex9/smult.c) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex9/fullGraph.png) | ![![](http://homepages.dcc.ufmg.br/~fernando/images/flowchart.jpg)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex9/subgraphLines0.png) | [![](http://cuda.dcc.ufmg.br/flowtracker/examples/images.png)](http://cuda.dcc.ufmg.br/flowtracker/examples/ex9/subgraphASCIILines0.txt)|**smult.c**:     |